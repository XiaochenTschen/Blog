#### 判断字符串a是否包含字符串b的所有字符
首先应该想到，利用两个map或者vector来存储字符串中的字符信息。
后续判断的过程可以有不同的方法，比较好的方法是引入另一个记录信息的量，当b中的字符被找到的时候该变量加一，某个字符已经被完全找到后不再增加，最后判断该变量是否和b字符串长度相等。

#### 判断字符串a和字符串b是否有相同的字符
使用不同的数据结构有不同的解法，当字符串中只包含小写字符的时候，可以使用一个int数据来记录字符串中含有哪些字符，然后通过关系和来判断是否有相同字符。

#### KMP算法
KMP算法的核心思想是，当一次匹配失败后，尽可能地利用这次匹配得到地信息。

比如说有主串Source String(s)和模式串Pattern String(p)，最容易想到的匹配模式就是利用双重循环，从s地开头和p地开头进行匹配，当某次匹配失败后移动s地下标到下一位继续进行匹配，显然该算法地时间复杂度是O(mn)，当字符串长度增加时会变得很低效。

KMP算法引入了一个next数组，当某次匹配失败后，可以将p快速移动到下一个跟s匹配的位置，从而减少不必要的匹配。

next数组地意义会稍微有点绕，next[i] = k表示，p从0到第i个元素(0基准)所构成的子串，该字串中前k个字符和后k个字符相同，也就是大家说的前后缀相同的最大长度。注意，k不能取i+1,因为这表示字符串和本身相等，没有意义。
比如字符串aabbcaabb:
1. i=0时，next[0] = 0。
2. i=1，"aa"子串前后缀相等额最大长度为1，因此next[1] = 1。
3. i=2，"aab"子串没有相同的前后缀，next[2] = 0.
4. i=3，"aab"子串没有相同的前后缀，next[3] = 0.
5. i=4，"aabb"子串没有相同的前后缀，next[4] = 0.
6. i=5，"aabbc"子串没有相同的前后缀，next[5] = 0.
7. i=6，"aabbca"子串前后缀相等额最大长度为1，因此next[6] = 1。
8. i=7，"aabbcaa"子串前后缀相等额最大长度为2，因此next[7] = 2。
9. i=8，"aabbcaab"子串前后缀相等额最大长度为3，因此next[8] = 3。
10. i=9，前后缀不跟字符串本身相比较，next[9] = 4。

有了next数组之后，匹配是如何加速的：匹配失败的那一位要继续和p[next[r-1]]进行匹配，r是失败的位置。

在这里，重点又来到了如何实现next数组，采用最简单的方法代码如下
```c++
int next[p.length()];
for(int i = 0; i < p.length(); ++i)
{
    int count = 0;
    for(int j = 0; j < i; ++j)
    {
        if(p[j] == p[i-j])
            ++count;
    }
    next[i] = count;
}
```
上面的代码容易理解，但是时间复杂度仍然很高。还有一种利用next数组递推计算的方法，这里不详细记录，网上很多解释，明白技术细节后代码需要自己能够写出来。
```c++
int next[p.length()];
int i = 1, now = 0;
while(i < p.length())
{
    if(p[now] == p[i])
    {
        ++now;
        next[i] = next[i-1] + 1;
        i++;
    }
    else if(now != 0)
    {
        now = next[now-1];
    }
    else
    {
        p[i] = 0;
        i++;
    }
}
```

进行匹配的代码如下
```c++
int i = 0, j = 0;
vector<int> ans;
while(i < s.length())
{
    if(s[i] == p[j])
    {
        ++i;
        ++j;
    }
    else if(j != 0)
    {
        j = next[j - 1];
    }
    else
        ++i;
    
    if(j == p.length())
    {
        ans.push_back(i-j+1);
        j = next[j-1];
    }
}
```

