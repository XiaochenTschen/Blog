**问题描述**：给定一个直方图，每个条形的宽为1，找出直方图中面积最大的矩形。

常用的解法是Using Stack：
遍历直方图中的每一个条形，用一个栈来保持那些还没有找到其右边界的条形的索引，一个条形右边界意味着右边的条形比该条形短，类似于木桶，没找到边界的索引依次压入栈中，当找到比栈顶元素低的条形时，弹出栈顶元素，并计算矩形面积。

**问题实例**：给定一个直方图数组 heights = [2,1,5,6,2,3]，你需要找出能够形成的最大矩形的面积。
```c
int largestRectangleArea(vector<int>& heights) {
    stack<int> s;
    heights.push_back(0);  // 添加一个高度为0的条形，以确保所有的条形都能被处理
    int maxArea = 0;
    
    for(int i = 0; i < heights.size(); i++) {
        while(!s.empty() && heights[s.top()] > heights[i]) {
            int height = heights[s.top()]; s.pop();
            int width = s.empty() ? i : i - s.top() - 1;
            maxArea = max(maxArea, height * width);
        }
        s.push(i);
    }
    
    return maxArea;
}
```

**该问题的变种问题**：如何找出一个二维数组当中面积最大的矩形。
变种问题的难点在于，条形不是从最底部出发向上生长的，它可能从任意位置出发生长。但是我们可以把二维数组的每一行作为一个底，只要我们知道以不同行为底向上生长的条形高度，就可以计算得出该行为底的条件下最大矩形，遍历每一行得到一个数值，最终取最大值即可。示例流程如下：
1. 对于每一行，我们都可以计算一个高度数组，其中高度数组的每一个元素代表当前行为底，向上连续1的数量。例如对于下面的二维数组：
```c

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
```

其对应的高度数组为：
```c
1 0 1 0 0
2 0 2 1 1
3 1 3 2 2
4 0 0 3 0
```

2. 对于每一行的高度数组，我们可以使用 "Largest Rectangle in Histogram" 的解法来找出该行为底时的最大矩形面积。重复这个过程，我们可以得到每一行为底时的最大矩形面积。

3. 最后，我们只需要从所有的最大矩形面积中选出最大的那个。

